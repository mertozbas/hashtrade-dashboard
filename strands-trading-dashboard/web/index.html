<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Trading Agent Dashboard</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    :root{--bg:#0b1220;--panel:#0f1a2e;--panel2:#0c1629;--text:#e7eefc;--muted:#9bb0d1;--line:#203152;--accent:#6aa6ff;--good:#2ee59d;--bad:#ff5c7a;--warn:#ffd36a;--shadow:0 8px 30px rgba(0,0,0,.35);--radius:14px;--mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--sans:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;font-family:var(--sans);color:var(--text);background:radial-gradient(1200px 600px at 20% 0%, rgba(106,166,255,.18), transparent 60%),radial-gradient(900px 500px at 100% 20%, rgba(46,229,157,.10), transparent 60%),var(--bg);overflow:hidden}
    .app{height:100%;display:grid;grid-template-columns:520px 1fr 420px;grid-template-rows:64px 1fr 86px;gap:12px;padding:12px}
    header,footer{border:1px solid var(--line);background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));border-radius:var(--radius);box-shadow:var(--shadow)}
    header{grid-column:1/4;display:flex;align-items:center;justify-content:space-between;padding:10px 12px}
    footer{grid-column:1/4;display:flex;gap:12px;align-items:center;padding:10px 12px}
    .brand{display:flex;gap:10px;align-items:center}.logo{width:34px;height:34px;border-radius:10px;background:conic-gradient(from 180deg,var(--accent),rgba(46,229,157,.9),rgba(255,92,122,.9),var(--accent))}
    .brand h1{font-size:14px;margin:0}.sub{font-size:12px;color:var(--muted)}
    .top{display:flex;gap:10px;align-items:center;padding:8px 10px;border:1px solid var(--line);background:rgba(255,255,255,.02);border-radius:12px}
    .pill{font-family:var(--mono);font-size:12px;color:var(--muted)}
    .balance{font-family:var(--mono);font-size:14px}
    .panel{border:1px solid var(--line);background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;display:flex;flex-direction:column;min-height:0}
    .hd{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--line);background:rgba(0,0,0,.12)}
    .bd{padding:12px;overflow:auto;min-height:0}

    .chat{display:flex;flex-direction:column;gap:10px}
    .turn{border:1px solid rgba(32,49,82,.9);background:rgba(15,26,46,.55);border-radius:12px;overflow:hidden}
    .msgRow{padding:10px 12px;border-bottom:1px solid rgba(32,49,82,.7)}
    .msgRow.user{background:rgba(106,166,255,.10)}
    .msgRow.assistant{background:rgba(0,0,0,.12)}
    .msgRow pre{background:#0a0f1c;padding:10px;border-radius:10px;overflow:auto}
    .msgRow code{font-family:var(--mono);font-size:12px}
    .ts{font-family:var(--mono);font-size:11px;color:var(--muted)}
    .tool-status{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;margin:8px 0;border:1px solid rgba(32,49,82,.9);border-radius:999px;background:rgba(255,255,255,.03);font-size:12px;color:var(--muted)}
    .tool-status.success{color:var(--good);border-color:rgba(46,229,157,.35)}
    .tool-status.error{color:var(--bad);border-color:rgba(255,92,122,.35)}
    .loading-cursor{display:inline-block;width:2px;height:1rem;background:#fff;margin-left:6px;animation:blink 1s infinite}
    @keyframes blink{0%,50%{opacity:1}51%,100%{opacity:0}}

    .timeline{display:flex;flex-direction:column;gap:10px}
    .event{border:1px solid rgba(32,49,82,.9);background:rgba(15,26,46,.7);border-radius:12px;padding:10px}
    .row{display:flex;justify-content:space-between;gap:10px}
    .msg{margin-top:6px;font-size:13px;line-height:1.35;white-space:pre-wrap;word-break:break-word}

    .controls{display:flex;align-items:center;gap:10px}
    .btn{border:1px solid var(--line);background:rgba(255,255,255,.03);color:var(--text);padding:8px 10px;border-radius:12px;cursor:pointer;font-size:12px}
    .btn.primary{border-color:rgba(106,166,255,.55);background:rgba(106,166,255,.12)}
    .sliderWrap{display:flex;align-items:center;gap:10px;flex:1}
    input[type=range]{width:100%}
    .timeReadout{font-family:var(--mono);font-size:12px;color:var(--muted);min-width:260px;text-align:right}
    .chatInputWrap{display:flex;align-items:center;gap:10px;flex:1.2}
    .chatInput{flex:1;background:rgba(0,0,0,.18);border:1px solid var(--line);border-radius:12px;padding:10px 12px;color:var(--text);font-size:13px;outline:none}
    .chatInput:focus{border-color:rgba(106,166,255,.55)}

    /* chart */
    .chartWrap{height:100%;display:flex;flex-direction:column;gap:10px}
    .canvasWrap{flex:1;border:1px solid var(--line);background:var(--panel2);border-radius:12px;overflow:hidden;position:relative}
    canvas{display:block;width:100%;height:100%}
    .legend{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
    .dot{width:8px;height:8px;border-radius:99px;display:inline-block;margin-right:6px}

    @media (max-width:1200px){body{overflow:auto}.app{height:auto;grid-template-columns:1fr;grid-template-rows:auto}header,footer{grid-column:1}}

    /* Settings Modal */
    .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal-overlay.show{display:flex}
    .modal{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);padding:24px;width:400px;max-width:90%}
    .modal h2{margin:0 0 20px;font-size:18px;color:var(--text)}
    .form-group{margin-bottom:16px}
    .form-group label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    .form-group input,.form-group select{width:100%;background:rgba(0,0,0,.25);border:1px solid var(--line);border-radius:10px;padding:10px 12px;color:var(--text);font-size:13px;outline:none}
    .form-group input:focus,.form-group select:focus{border-color:var(--accent)}
    .form-row{display:flex;gap:12px}
    .form-row .form-group{flex:1}
    .modal-actions{display:flex;gap:10px;margin-top:20px}
    .modal-actions .btn{flex:1}
    .status-dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px}
    .status-dot.connected{background:var(--good)}
    .status-dot.disconnected{background:var(--bad)}
    .live-indicator{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:20px;font-size:11px;background:rgba(46,229,157,0.15);color:var(--good);border:1px solid rgba(46,229,157,0.3)}
    .live-indicator.paused{background:rgba(255,211,106,0.15);color:var(--warn);border-color:rgba(255,211,106,0.3)}
    .live-dot{width:6px;height:6px;border-radius:50%;background:var(--good);animation:pulse 1.5s infinite}
    .live-indicator.paused .live-dot{background:var(--warn);animation:none}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand"><div class="logo"></div><div><h1>Trading Agent Dashboard <span class="sub">(WS streaming)</span></h1><div class="sub" id="conn"><span class="status-dot disconnected"></span>disconnected</div></div></div>
      <div class="top">
        <div><div class="pill">TOTAL</div><div class="balance"><span id="balTotal">$0.00</span></div></div>
        <div><div class="pill">AVAILABLE</div><div class="balance"><span id="balFree">$0.00</span></div></div>
        <div><div class="pill">USDT</div><div class="balance"><span id="balUsdt">0.00</span></div></div>
        <div><div class="pill">SYMBOL</div><div class="balance" id="sym">BTC/USDT</div></div>
        <div class="live-indicator paused" id="liveIndicator"><span class="live-dot"></span><span id="liveText">Paused</span></div>
        <button class="btn" id="btnSettings">Settings</button>
      </div>
    </header>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
      <div class="modal">
        <h2>Exchange Settings</h2>
        <div class="form-group">
          <label>Exchange</label>
          <select id="settingsExchange">
            <option value="bybit">Bybit</option>
            <option value="binance">Binance</option>
            <option value="okx">OKX</option>
            <option value="kucoin">KuCoin</option>
            <option value="kraken">Kraken</option>
            <option value="coinbase">Coinbase</option>
          </select>
        </div>
        <div class="form-group">
          <label>API Key</label>
          <input type="text" id="settingsApiKey" placeholder="Enter your API key" autocomplete="off" />
        </div>
        <div class="form-group">
          <label>API Secret</label>
          <input type="password" id="settingsApiSecret" placeholder="Enter your API secret" autocomplete="off" />
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Symbol</label>
            <input type="text" id="settingsSymbol" value="BTC/USDT" placeholder="BTC/USDT" />
          </div>
          <div class="form-group">
            <label>Timeframe</label>
            <select id="settingsTimeframe">
              <option value="1m">1 minute</option>
              <option value="5m">5 minutes</option>
              <option value="15m">15 minutes</option>
              <option value="1h">1 hour</option>
              <option value="4h">4 hours</option>
              <option value="1d">1 day</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Live Update Interval</label>
          <select id="settingsInterval">
            <option value="0">Disabled</option>
            <option value="5000" selected>5 seconds</option>
            <option value="10000">10 seconds</option>
            <option value="30000">30 seconds</option>
            <option value="60000">1 minute</option>
          </select>
        </div>
        <div class="modal-actions">
          <button class="btn" id="btnSettingsCancel">Cancel</button>
          <button class="btn primary" id="btnSettingsSave">Save & Connect</button>
        </div>
      </div>
    </div>

    <section class="panel" style="grid-column:1;grid-row:2;">
      <div class="hd"><div>Market Graph</div><div class="ts" id="chartMeta">waiting...</div></div>
      <div class="bd" style="height:100%">
        <div class="chartWrap">
          <div class="legend">
            <span><span class="dot" style="background:var(--accent)"></span>close</span>
            <span><span class="dot" style="background:var(--good)"></span>buy</span>
            <span><span class="dot" style="background:var(--bad)"></span>sell</span>
          </div>
          <div class="canvasWrap"><canvas id="chart"></canvas></div>
          <div class="sub">Chart updates via UI action: fetch_ohlcv (server calls ccxt_generic).</div>
        </div>
      </div>
    </section>

    <section class="panel" style="grid-column:2;grid-row:2;">
      <div class="hd"><div>History of Actions</div><div class="ts">items: <span id="eventCount">0</span></div></div>
      <div class="bd"><div class="timeline" id="timeline"></div></div>
    </section>

    <section class="panel" style="grid-column:3;grid-row:2;">
      <div class="hd"><div>Agent Screen</div><div class="ts">turns: <span id="turnCount">0</span></div></div>
      <div class="bd"><div class="chat" id="chat"></div></div>
    </section>

    <footer>
      <div class="controls">
        <button class="btn" id="btnConnect">Connect</button>
        <button class="btn" id="btnPrev">⟵</button>
        <button class="btn primary" id="btnPlay">Play</button>
        <button class="btn" id="btnNext">⟶</button>
        <button class="btn" id="btnRefresh">Refresh Chart</button>
        <button class="btn" id="btnClearHistory">Clear History</button>
      </div>
      <div class="sliderWrap">
        <input type="range" id="timeSlider" min="0" max="0" step="1" value="0" />
        <div class="timeReadout" id="timeReadout">t=0</div>
      </div>
      <div class="chatInputWrap">
        <input class="chatInput" id="chatInput" placeholder='Send message to agent (e.g. "5 dollars eth")' />
        <button class="btn primary" id="btnSend">Send</button>
      </div>
    </footer>
  </div>

<script>
  marked.setOptions({
    highlight: (code, lang) => {
      try{
        if (lang && hljs.getLanguage(lang)) return hljs.highlight(code, {language: lang}).value;
        return hljs.highlightAuto(code).value;
      } catch { return code; }
    },
    breaks: true,
    gfm: true
  });

  const state = {
    playing:false, playTimer:null, nowIndex:0,
    streamEvents:[],       // raw stream events for time travel (chat + history + balance + ohlcv)
    streamSnaps:[],        // snapshots at each event index (for time travel)
    historyItems:[],       // all history items (full list)
    chart: { symbol:'BTC/USDT', tf:'1m', ohlcv:[] },
    // Settings & credentials
    settings: {
      exchange: 'bybit',
      apiKey: '',
      apiSecret: '',
      symbol: 'BTC/USDT',
      timeframe: '1m',
      liveInterval: 5000
    },
    liveTimer: null
  };

  let ws = null;

  // Load settings from localStorage
  function loadSettings() {
    try {
      const saved = localStorage.getItem('tradingDashboardSettings');
      if (saved) {
        const parsed = JSON.parse(saved);
        Object.assign(state.settings, parsed);
      }
    } catch (e) { console.warn('Failed to load settings:', e); }

    // Update UI
    document.getElementById('settingsExchange').value = state.settings.exchange;
    document.getElementById('settingsApiKey').value = state.settings.apiKey;
    document.getElementById('settingsApiSecret').value = state.settings.apiSecret;
    document.getElementById('settingsSymbol').value = state.settings.symbol;
    document.getElementById('settingsTimeframe').value = state.settings.timeframe;
    document.getElementById('settingsInterval').value = String(state.settings.liveInterval);

    // Update chart state
    state.chart.symbol = state.settings.symbol;
    state.chart.tf = state.settings.timeframe;
    document.getElementById('sym').textContent = state.settings.symbol;
  }

  function saveSettings() {
    state.settings.exchange = document.getElementById('settingsExchange').value;
    state.settings.apiKey = document.getElementById('settingsApiKey').value;
    state.settings.apiSecret = document.getElementById('settingsApiSecret').value;
    state.settings.symbol = document.getElementById('settingsSymbol').value;
    state.settings.timeframe = document.getElementById('settingsTimeframe').value;
    state.settings.liveInterval = parseInt(document.getElementById('settingsInterval').value, 10);

    // Save to localStorage (note: API keys in localStorage is not ideal for production)
    localStorage.setItem('tradingDashboardSettings', JSON.stringify(state.settings));

    // Update chart state
    state.chart.symbol = state.settings.symbol;
    state.chart.tf = state.settings.timeframe;
    document.getElementById('sym').textContent = state.settings.symbol;

    // Send credentials to server
    sendCredentials();

    // Restart live timer
    startLiveTimer();

    // Close modal
    closeSettingsModal();

    // Fetch chart and balance immediately
    requestChart();
    requestBalance();
  }

  function sendCredentials() {
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({
      type: 'credentials',
      exchange: state.settings.exchange,
      apiKey: state.settings.apiKey,
      apiSecret: state.settings.apiSecret
    }));
  }

  function openSettingsModal() {
    document.getElementById('settingsModal').classList.add('show');
  }

  function closeSettingsModal() {
    document.getElementById('settingsModal').classList.remove('show');
  }

  function startLiveTimer() {
    // Clear existing timer
    if (state.liveTimer) {
      clearInterval(state.liveTimer);
      state.liveTimer = null;
    }

    const indicator = document.getElementById('liveIndicator');
    const liveText = document.getElementById('liveText');

    if (state.settings.liveInterval > 0) {
      indicator.classList.remove('paused');
      liveText.textContent = 'Live';

      state.liveTimer = setInterval(() => {
        if (ws && ws.readyState === 1) {
          requestChart();
        }
      }, state.settings.liveInterval);
    } else {
      indicator.classList.add('paused');
      liveText.textContent = 'Paused';
    }
  }

  function stopLiveTimer() {
    if (state.liveTimer) {
      clearInterval(state.liveTimer);
      state.liveTimer = null;
    }
    const indicator = document.getElementById('liveIndicator');
    const liveText = document.getElementById('liveText');
    indicator.classList.add('paused');
    liveText.textContent = 'Paused';
  }

  // Turn-based UI (live mode only when slider at end)
  const turns = new Map(); // turnId -> {root, userEl, assistantEl, contentEl, cursorEl, text, tools:[]}

  function isoNow(){ return new Date().toISOString(); }

  function escapeHtml(s){
    return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;');
  }

  // --- STREAM (time travel base) ---
  function addStreamEvent(type, msg){
    state.streamEvents.push({ts: isoNow(), type, msg});
    buildStreamSnaps();
    setIndex(state.streamEvents.length-1);
  }

  function buildStreamSnaps(){
    const snaps=[];
    let bal=null;
    let chart=null;
    let historyUpToNow=[];
    for(let i=0;i<state.streamEvents.length;i++){
      const e=state.streamEvents[i];
      if(e.type==='balance') bal=e.msg.data;
      if(e.type==='ohlcv') chart=e.msg.data;
      if(e.type==='history') historyUpToNow = [...historyUpToNow, e.msg.data];
      if(e.type==='history_sync') historyUpToNow = Array.isArray(e.msg.data) ? [...e.msg.data] : [];
      if(e.type==='history_cleared') historyUpToNow = [];
      snaps.push({
        i,
        ts:e.ts,
        bal,
        chart,
        history: [...historyUpToNow],
        events: state.streamEvents.slice(0,i+1)
      });
    }
    state.streamSnaps=snaps;
    document.getElementById('timeSlider').max=String(Math.max(0, snaps.length-1));
  }

  function setIndex(i){
    state.nowIndex=Math.max(0, Math.min(i, state.streamSnaps.length-1));
    document.getElementById('timeSlider').value=String(state.nowIndex);
    renderAll();
  }

  function isLive(){
    return state.nowIndex >= Math.max(0, state.streamSnaps.length-1);
  }

  // --- HISTORY (actions only) ---
  function addHistoryItem(rec){
    if(!rec) return;
    state.historyItems.push(rec);
    // history is now part of streamEvents for time travel
  }

  // --- RENDER ---
  function renderAll(){
    const snap = state.streamSnaps[state.nowIndex] || {events:[], bal:null, chart:null, history:[], ts:''};
    document.getElementById('timeReadout').textContent = snap.ts ? `index ${state.nowIndex}/${Math.max(0,state.streamSnaps.length-1)} • ${snap.ts}` : 't=0';

    // balance display
    if (snap.bal){
      const bal = snap.bal;
      const btcPrice = state.chart.ohlcv?.length ? state.chart.ohlcv[state.chart.ohlcv.length-1][4] : 0;

      // New format: {status, total: {USDT: x, BTC: y}, free: {...}}
      if (bal.total) {
        // Calculate total USD value
        const totalUsdt = parseFloat(bal.total.USDT || bal.total.USD || 0);
        const totalBtc = parseFloat(bal.total.BTC || 0);
        const totalUsd = totalUsdt + (totalBtc * btcPrice);

        // Calculate free/available USD value
        const freeUsdt = parseFloat(bal.free?.USDT || bal.free?.USD || 0);
        const freeBtc = parseFloat(bal.free?.BTC || 0);
        const freeUsd = freeUsdt + (freeBtc * btcPrice);

        document.getElementById('balTotal').textContent = '$' + totalUsd.toFixed(2);
        document.getElementById('balFree').textContent = '$' + freeUsd.toFixed(2);
        document.getElementById('balUsdt').textContent = totalUsdt.toFixed(2);
      } else {
        // Legacy format fallback
        const t = (bal.content?.[0]?.text ?? JSON.stringify(bal)).toString();
        const usd = t.match(/\$\s*(\d+(?:\.\d+)?)/)?.[1] ?? t.match(/(\d+(?:\.\d+)?)/)?.[1] ?? '0.00';
        document.getElementById('balTotal').textContent = '$' + usd;
        document.getElementById('balFree').textContent = '$' + usd;
        document.getElementById('balUsdt').textContent = (t.match(/USDT[^0-9]*(\d+(?:\.\d+)?)/i)?.[1] ?? '');
      }
    }

    // chart
    if (snap.chart){
      state.chart = snap.chart;
      document.getElementById('sym').textContent = snap.chart.symbol;
      document.getElementById('chartMeta').textContent = `${snap.chart.symbol} • ${snap.chart.timeframe} • points ${snap.chart.ohlcv.length}`;
      drawChart(snap.chart.ohlcv);
    } else {
      drawChart([]);
    }

    // center: history panel from snapshot (time travel enabled)
    renderHistoryPanel(snap.history || []);

    // right: time travel chat
    renderChatFromStream(snap.events);
  }

  function renderHistoryPanel(historyForSnap){
    // Use snapshot history if provided, otherwise use full historyItems (for live mode)
    const items = historyForSnap.length > 0 ? historyForSnap : state.historyItems;
    document.getElementById('eventCount').textContent = String(items.length);
    const tl=document.getElementById('timeline');
    tl.innerHTML='';

    // show last 250 actions
    const displayItems = items.slice(-250);

    for(const r of displayItems){
      const d=document.createElement('div'); d.className='event';
      const ts = r.ts ? new Date(r.ts*1000).toISOString() : isoNow();
      const type = r.type || 'action';
      let msg = '';
      if(type==='tool_start') msg = `Tool start: ${r.data?.tool || ''} (#${r.data?.tool_number||''})`;
      else if(type==='tool_end') msg = `Tool end: ${r.data?.status || ''} (${r.data?.success?'success':'error'})`;
      else if(type==='balance') msg = 'Balance snapshot';
      else if(type==='ui') msg = `UI: ${r.data?.action || 'action'}`;
      else msg = JSON.stringify(r.data ?? r);

      d.innerHTML = `<div class="row"><div class="ts">${escapeHtml(type)}</div><div class="ts">${escapeHtml(ts)}</div></div><div class="msg">${escapeHtml(msg)}</div>`;
      tl.appendChild(d);
    }
  }

  // --- CHAT time travel: rebuild DOM from events up to snapshot ---
  function clearChat(){
    document.getElementById('chat').innerHTML='';
    turns.clear();
    document.getElementById('turnCount').textContent = '0';
  }

  function createTurn(turnId, userMessage){
    const root=document.createElement('div');
    root.className='turn';
    root.dataset.turnId=turnId;

    const user=document.createElement('div');
    user.className='msgRow user';
    user.innerHTML = `<div class="ts">${escapeHtml(isoNow())}</div><div class="msg">${escapeHtml(userMessage)}</div>`;

    const assistant=document.createElement('div');
    assistant.className='msgRow assistant';

    const content=document.createElement('div');
    content.className='msg';
    content.style.whiteSpace='normal';

    const cursor=document.createElement('span');
    cursor.className='loading-cursor';

    assistant.appendChild(content);
    assistant.appendChild(cursor);

    root.appendChild(user);
    root.appendChild(assistant);

    const chat=document.getElementById('chat');
    chat.appendChild(root);

    turns.set(turnId, {root, userEl:user, assistantEl:assistant, contentEl:content, cursorEl:cursor, text:'', tools:[]});
    document.getElementById('turnCount').textContent = String(turns.size);
    return turns.get(turnId);
  }

  function updateTurnContent(turnId, delta){
    const turn=turns.get(turnId);
    if(!turn) return;
    turn.text += (delta || '');

    const html = marked.parse(turn.text);
    turn.contentEl.innerHTML = html;
    turn.contentEl.querySelectorAll('pre code').forEach((block)=>hljs.highlightElement(block));
  }

  function addToolStatus(turnId, toolName, toolNumber){
    const turn=turns.get(turnId);
    if(!turn) return;
    const tool=document.createElement('div');
    tool.className='tool-status';
    tool.textContent = `Tool #${toolNumber}: ${toolName}`;
    turn.assistantEl.insertBefore(tool, turn.contentEl);
    turn.tools.push(tool);
  }

  function updateToolStatus(turnId, success){
    const turn=turns.get(turnId);
    if(!turn || !turn.tools.length) return;
    const last=turn.tools[turn.tools.length-1];
    last.className = 'tool-status ' + (success ? 'success' : 'error');
    last.textContent = last.textContent + (success ? ' ✓' : ' ✗');
  }

  function finalizeTurn(turnId){
    const turn=turns.get(turnId);
    if(!turn) return;
    if(turn.cursorEl && turn.cursorEl.parentNode) turn.cursorEl.remove();
  }

  function renderChatFromStream(streamEvents){
    // rebuild from scratch for correctness when scrubbing
    clearChat();

    for(const e of streamEvents){
      const msg = e.msg || {};
      switch(e.type){
        case 'turn_start':
          createTurn(msg.turn_id, msg.data || '');
          break;
        case 'chunk':
          updateTurnContent(msg.turn_id, msg.data || '');
          break;
        case 'tool_start':
          addToolStatus(msg.turn_id, msg.data || 'tool', msg.tool_number || 1);
          break;
        case 'tool_end':
          updateToolStatus(msg.turn_id, !!msg.success);
          break;
        case 'turn_end':
          finalizeTurn(msg.turn_id);
          break;
      }
    }

    // scroll bottom
    const chat=document.getElementById('chat');
    chat.scrollTop=chat.scrollHeight;
  }

  // --- WS ---
  function connect(){
    if (ws && ws.readyState===1) return;
    ws = new WebSocket('ws://127.0.0.1:8090');
    document.getElementById('conn').innerHTML='<span class="status-dot disconnected"></span>connecting...';

    ws.onopen=()=>{
      document.getElementById('conn').innerHTML='<span class="status-dot connected"></span>connected';
      // Send credentials first
      sendCredentials();
      // Then request chart and balance
      requestChart();
      requestBalance();
      // Start live timer
      startLiveTimer();
    };

    ws.onclose=()=>{
      document.getElementById('conn').innerHTML='<span class="status-dot disconnected"></span>disconnected';
      stopLiveTimer();
    };

    ws.onerror=(e)=>{
      console.log('ws error', e);
    };

    ws.onmessage=(ev)=>{
      let msg=null;
      try{ msg=JSON.parse(ev.data); }catch{ msg={type:'raw', data:ev.data}; }
      const t=msg.type;

      // Actions history stream - add to streamEvents for time travel
      if(t==='history_sync'){
        const arr = Array.isArray(msg.data) ? msg.data : [];
        state.historyItems = arr;
        // Add to stream events so time travel works
        addStreamEvent(t, msg);
        return;
      }
      if(t==='history'){
        addHistoryItem(msg.data);
        // Add to stream events so time travel works
        addStreamEvent(t, msg);
        // Auto-switch chart if trade event contains a symbol
        checkAndSwitchChartSymbol(msg.data);
        return;
      }
      if(t==='history_cleared'){
        state.historyItems = [];
        addStreamEvent(t, msg);
        return;
      }

      // Store stream events for time travel
      if (t==='turn_start' || t==='chunk' || t==='tool_start' || t==='tool_end' || t==='turn_end' || t==='balance' || t==='ohlcv' || t==='error'){
        addStreamEvent(t, msg);
      }

      // Live UI updates ONLY when at end of timeline
      if(!isLive()) return;

      switch(t){
        case 'connected':
          return;
        case 'turn_start':
          createTurn(msg.turn_id, msg.data || '');
          break;
        case 'chunk':
          updateTurnContent(msg.turn_id, msg.data || '');
          break;
        case 'tool_start':
          addToolStatus(msg.turn_id, msg.data || 'tool', msg.tool_number || 1);
          break;
        case 'tool_end':
          updateToolStatus(msg.turn_id, !!msg.success);
          break;
        case 'turn_end':
          finalizeTurn(msg.turn_id);
          break;
        case 'error':
          if (msg.turn_id) finalizeTurn(msg.turn_id);
          break;
      }

      // keep scrolled
      const chat=document.getElementById('chat');
      chat.scrollTop=chat.scrollHeight;
    };
  }

  function send(){
    const input=document.getElementById('chatInput');
    const text=input.value.trim();
    if(!text) return;
    input.value='';
    ws?.send(text);
  }

  function requestChart(){
    const req = {
      type: 'ui',
      action: 'fetch_ohlcv',
      exchange: state.settings.exchange,
      symbol: state.settings.symbol,
      timeframe: state.settings.timeframe,
      limit: 240
    };
    ws?.send(JSON.stringify(req));
  }

  function requestBalance(){
    const req = {
      type: 'ui',
      action: 'fetch_balance',
      exchange: state.settings.exchange,
      apiKey: state.settings.apiKey,
      apiSecret: state.settings.apiSecret
    };
    ws?.send(JSON.stringify(req));
  }

  // Auto-switch chart when a trade event with different symbol is detected
  function checkAndSwitchChartSymbol(historyData){
    if (!historyData) return;

    // Look for symbol in various formats
    let symbol = null;

    // Direct symbol field
    if (historyData.symbol) {
      symbol = historyData.symbol;
    }
    // Nested in data object
    else if (historyData.data?.symbol) {
      symbol = historyData.data.symbol;
    }
    // Check if it's a trade/order event
    else if (historyData.type === 'trade' || historyData.type === 'order' || historyData.type === 'simulated_trade') {
      symbol = historyData.data?.symbol || historyData.symbol;
    }

    // If we found a symbol and it's different from current, switch chart
    if (symbol && symbol !== state.settings.symbol) {
      // Normalize symbol format (e.g., "ETHUSDT" -> "ETH/USDT")
      if (!symbol.includes('/') && symbol.length >= 6) {
        // Try to detect common quote currencies
        const quotes = ['USDT', 'USDC', 'BTC', 'ETH', 'USD', 'EUR'];
        for (const q of quotes) {
          if (symbol.endsWith(q)) {
            symbol = symbol.slice(0, -q.length) + '/' + q;
            break;
          }
        }
      }

      console.log(`Auto-switching chart to ${symbol}`);
      state.settings.symbol = symbol;
      state.chart.symbol = symbol;
      document.getElementById('sym').textContent = symbol;
      document.getElementById('settingsSymbol').value = symbol;
      // Save to localStorage
      localStorage.setItem('tradingDashboardSettings', JSON.stringify(state.settings));
      // Request new chart data
      requestChart();
    }
  }

  function clearHistory(){
    ws?.send(JSON.stringify({type:'history', action:'clear'}));
  }

  function togglePlay(){
    state.playing=!state.playing;
    document.getElementById('btnPlay').textContent = state.playing ? 'Pause' : 'Play';
    if(state.playing){
      state.playTimer=setInterval(()=>{
        if(!state.streamSnaps.length) return;
        if(state.nowIndex>=state.streamSnaps.length-1){
          state.playing=false;
          document.getElementById('btnPlay').textContent='Play';
          clearInterval(state.playTimer);
          return;
        }
        setIndex(state.nowIndex+1);
      }, 250);
    } else {
      clearInterval(state.playTimer);
    }
  }

  // Simple OHLCV close line chart
  function drawChart(ohlcv){
    const canvas = document.getElementById('chart');
    const wrap = canvas.parentElement;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = wrap.clientWidth, h = wrap.clientHeight;
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='rgba(0,0,0,0.12)';
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle='rgba(32,49,82,0.7)';
    ctx.lineWidth=1;
    for(let i=0;i<=6;i++){ const y=(h/6)*i; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    for(let i=0;i<=8;i++){ const x=(w/8)*i; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }

    if(!ohlcv || !ohlcv.length){
      ctx.fillStyle='rgba(231,238,252,0.7)';
      ctx.font='12px '+getComputedStyle(document.body).fontFamily;
      ctx.fillText('No OHLCV yet. Click Refresh Chart.', 12, 18);
      return;
    }

    const xs = ohlcv.map(r => r[0]);
    const closes = ohlcv.map(r => r[4]);
    const minY = Math.min(...closes);
    const maxY = Math.max(...closes);
    const pad = (maxY-minY)*0.1 || 1;
    const lo=minY-pad, hi=maxY+pad;

    const x0=xs[0], x1=xs[xs.length-1];
    const xScale=(t)=> ((t-x0)/(x1-x0))*(w-20)+10;
    const yScale=(v)=> h-(((v-lo)/(hi-lo))*(h-20)+10);

    ctx.strokeStyle='rgba(106,166,255,0.95)';
    ctx.lineWidth=2;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const x=xScale(xs[i]);
      const y=yScale(closes[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.fillStyle='rgba(231,238,252,0.9)';
    ctx.font='12px '+getComputedStyle(document.body).fontFamily;
    ctx.fillText(`Last close: ${closes[closes.length-1].toFixed(2)}`, 12, 18);
  }

  document.getElementById('btnConnect').onclick=connect;
  document.getElementById('btnSend').onclick=send;
  document.getElementById('chatInput').addEventListener('keydown', e=>{ if(e.key==='Enter') send(); });
  document.getElementById('btnPrev').onclick=()=>setIndex(state.nowIndex-1);
  document.getElementById('btnNext').onclick=()=>setIndex(state.nowIndex+1);
  document.getElementById('btnPlay').onclick=togglePlay;
  document.getElementById('btnRefresh').onclick=requestChart;
  document.getElementById('btnClearHistory').onclick=clearHistory;
  document.getElementById('timeSlider').addEventListener('input', (e)=>setIndex(parseInt(e.target.value||'0',10)));

  // Settings modal
  document.getElementById('btnSettings').onclick=openSettingsModal;
  document.getElementById('btnSettingsCancel').onclick=closeSettingsModal;
  document.getElementById('btnSettingsSave').onclick=saveSettings;
  document.getElementById('settingsModal').onclick=(e)=>{
    if(e.target.id==='settingsModal') closeSettingsModal();
  };

  // Load settings and auto connect
  loadSettings();
  connect();
</script>
</body>
</html>
